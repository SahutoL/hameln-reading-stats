import React, {
  useMemo,
  useState,
  useRef,
  useCallback,
  forwardRef,
} from "react";
import {
  BarChart,
  Bar,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  Legend,
  ResponsiveContainer,
} from "recharts";
import {
  ProcessedData,
  ComparisonData,
  PersonalInsightsData,
  Achievement,
  AchievementTier,
} from "../types";
import StatCard from "./StatCard";
import ReadingGoal from "./ReadingGoal";
import ActivityCalendar from "./ActivityCalendar";
import ReadingTrends from "./ReadingTrends";
import ComparisonStats from "./ComparisonStats";
import PersonalInsights from "./PersonalInsights";
import PersonalStats from "./PersonalStats";
import {
  BookIcon,
  ChapterIcon,
  WordIcon,
  InformationCircleIcon,
  CalendarIcon,
  ShareIcon,
  LogoIcon,
  TrophyIcon,
  ShieldCheckIcon,
} from "./icons";
import LevelProgress from "./LevelProgress";
import Roadmap from "./Roadmap";
import Modal from "./Modal";
import Spinner from "./Spinner";

declare const html2canvas: any;

// --- Report Card Component ---
const getTierColor = (tier: AchievementTier): string => {
  switch (tier) {
    case "bronze":
      return "#CD7F32";
    case "silver":
      return "#C0C0C0";
    case "gold":
      return "#FFD700";
    case "platinum":
      return "#E5E4E2";
    case "diamond":
      return "#B9F2FF";
    case "special":
      return "#c084fc";
    default:
      return "#6B7280";
  }
};

const getTierName = (tier: AchievementTier): string => {
  switch (tier) {
    case "bronze":
      return "ブロンズ";
    case "silver":
      return "シルバー";
    case "gold":
      return "ゴールド";
    case "platinum":
      return "プラチナ";
    case "diamond":
      return "ダイヤモンド";
    case "special":
      return "スペシャル";
    default:
      return "";
  }
};

interface ReportCardProps {
  processedData: ProcessedData;
}

const ReportCardContent = forwardRef<HTMLDivElement, ReportCardProps>(
  ({ processedData }, ref) => {
    const { cumulativeData, levelData, longestStreak, mostProudAchievement } =
      processedData;

    return (
      <div
        ref={ref}
        className="w-[380px] h-[580px] bg-gradient-to-br from-[#1e1e24] to-[#0f0f14] p-6 flex flex-col font-sans text-white rounded-2xl border border-primary/20 shadow-2xl shadow-primary/20"
      >
        <header className="flex items-center gap-2 border-b border-white/10 pb-3">
          <LogoIcon className="w-8 h-8 text-primary" />
          <h2 className="text-xl font-bold">年間読書レポート</h2>
        </header>

        <main className="flex-grow flex flex-col justify-around py-4">
          <div className="text-center">
            <p className="text-gray-400 text-sm">読書レベル</p>
            <p className="text-6xl font-bold text-primary tracking-tighter">
              Lv. {levelData.level}
            </p>
          </div>

          <div className="grid grid-cols-2 gap-4 text-center">
            <div>
              <p className="text-3xl font-bold">
                {cumulativeData.word_count.toLocaleString()}
              </p>
              <p className="text-xs text-gray-400">累計読了文字数</p>
            </div>
            <div>
              <p className="text-3xl font-bold">
                {longestStreak.toLocaleString()}
              </p>
              <p className="text-xs text-gray-400">最長連続読書日数</p>
            </div>
          </div>

          {mostProudAchievement && (
            <div className="bg-white/5 p-4 rounded-lg text-center">
              <p className="text-xs text-primary font-bold">最も輝かしい称号</p>
              <ShieldCheckIcon
                tierColor={getTierColor(mostProudAchievement.tier)}
                className="w-12 h-12 mx-auto my-2"
              />
              <p className="text-lg font-bold">
                <span className="text-yellow-300">
                  [{getTierName(mostProudAchievement.tier)}]
                </span>{" "}
                {mostProudAchievement.name}
              </p>
              <p className="text-xs text-gray-400">
                {mostProudAchievement.description}
              </p>
            </div>
          )}
        </main>

        <footer className="text-center text-xs text-gray-500 pt-3 border-t border-white/10">
          <p>Generated by Hameln Reading Stats</p>
        </footer>
      </div>
    );
  }
);

interface ReportCardModalProps {
  isOpen: boolean;
  onClose: () => void;
  processedData: ProcessedData | null;
}

const ReportCardModal: React.FC<ReportCardModalProps> = ({
  isOpen,
  onClose,
  processedData,
}) => {
  const cardRef = useRef<HTMLDivElement>(null);
  const [processingAction, setProcessingAction] = useState<
    "download" | "share" | null
  >(null);

  const captureCardAsImage = useCallback(async (): Promise<Blob | null> => {
    if (typeof html2canvas === "undefined") {
      alert(
        "イメージ生成ライブラリの読み込みに失敗しました。ページをリロードして再度お試しください。"
      );
      return null;
    }
    if (!cardRef.current) return null;

    const canvas = await html2canvas(cardRef.current, {
      backgroundColor: "#1e1e24",
      scale: 2, // Increase resolution for better quality
    });

    return new Promise((resolve) => {
      canvas.toBlob((blob) => {
        resolve(blob);
      }, "image/jpeg");
    });
  }, []);

  const handleDownload = useCallback(async () => {
    setProcessingAction("download");
    try {
      const blob = await captureCardAsImage();
      if (blob) {
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.download = "reading-report-card.jpeg";
        link.href = url;
        document.body.appendChild(link); // Required for Firefox
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
      }
    } catch (error) {
      console.error("Failed to download image:", error);
      alert("画像のダウンロードに失敗しました。");
    } finally {
      setProcessingAction(null);
    }
  }, [captureCardAsImage]);

  const handleShare = useCallback(async () => {
    setProcessingAction("share");
    try {
      const blob = await captureCardAsImage();
      if (!blob) {
        throw new Error("Failed to generate image blob.");
      }

      const file = new File([blob], "reading-report-card.jpeg", {
        type: "image/jpeg",
      });
      const text = `私の年間読書レポートです！あなたも自分の読書データを可視化してみませんか？ #HamelnReadingStats`;
      const url = window.location.origin;

      // Use Web Share API if available (mainly on mobile)
      if (navigator.canShare && navigator.canShare({ files: [file] })) {
        await navigator.share({
          files: [file],
          title: "読書レポートカード",
          text: text,
          url: url,
        });
      } else {
        // Fallback for desktop browsers
        alert(
          "お使いのブラウザは画像の直接シェアに対応していません。画像をダウンロードした後、X (Twitter) に投稿してください。"
        );

        // Trigger download for the user
        const downloadUrl = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.download = "reading-report-card.jpeg";
        link.href = downloadUrl;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(downloadUrl);

        // Open Twitter intent in a new tab
        const twitterUrl = `https://twitter.com/intent/tweet?text=${encodeURIComponent(
          text
        )}&url=${encodeURIComponent(url)}`;
        setTimeout(() => {
          window.open(twitterUrl, "_blank", "noopener,noreferrer");
        }, 500);
      }
    } catch (error: any) {
      // User cancellation of the share dialog is not an error.
      if (error.name !== "AbortError") {
        console.error("Failed to share:", error);
        alert("シェア機能の実行中にエラーが発生しました。");
      }
    } finally {
      setProcessingAction(null);
    }
  }, [captureCardAsImage]);

  if (!processedData) return null;

  return (
    <Modal isOpen={isOpen} onClose={onClose} title="読書レポートカード">
      <div className="flex flex-col items-center gap-6">
        {/* Wrapper for responsive scaling */}
        <div className="w-full max-w-[380px]">
          <div className="aspect-[380/580] w-full h-auto relative">
            {/* The element to be captured by html2canvas must have fixed dimensions, so we scale it down. */}
            <div
              className="origin-top-left transform-gpu absolute top-0 left-0"
              style={{
                transform: "scale(calc(100% / 380px))",
                width: "380px",
                height: "580px",
              }}
            >
              <ReportCardContent processedData={processedData} ref={cardRef} />
            </div>
          </div>
        </div>

        <div className="flex flex-col sm:flex-row gap-4 w-full max-w-sm">
          <button
            onClick={handleDownload}
            disabled={processingAction !== null}
            className="w-full text-center px-4 py-2.5 font-semibold bg-secondary text-background rounded-lg hover:opacity-90 transition-all disabled:bg-gray-500 disabled:cursor-wait flex items-center justify-center"
          >
            {processingAction === "download" ? (
              <Spinner />
            ) : (
              "画像をダウンロード"
            )}
          </button>
          <button
            onClick={handleShare}
            disabled={processingAction !== null}
            className="w-full text-center px-4 py-2.5 font-semibold bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors disabled:bg-gray-500 disabled:cursor-wait flex items-center justify-center"
          >
            {processingAction === "share" ? (
              <Spinner />
            ) : (
              "X (Twitter) でシェア"
            )}
          </button>
        </div>
        <p className="text-xs text-gray-500 text-center max-w-sm">
          X (Twitter)
          でシェアする場合、お使いのブラウザによっては画像のダウンロード後に手動で添付する必要があります。
        </p>
      </div>
    </Modal>
  );
};
// --- End of Report Card Component ---

interface DashboardProps {
  processedData: ProcessedData;
}

const AnimatedCard: React.FC<{
  children: React.ReactNode;
  className?: string;
  delay?: number;
}> = ({ children, className = "", delay = 0 }) => {
  const style = {
    animationDelay: `${delay}ms`,
    animationFillMode: "backwards",
  } as React.CSSProperties;

  return (
    <div
      style={style}
      className={`bg-surface-glass backdrop-blur-xl border border-white/10 rounded-2xl shadow-lg p-4 md:p-6 animate-fade-in ${className}`}
    >
      {children}
    </div>
  );
};

const Dashboard: React.FC<DashboardProps> = ({ processedData }) => {
  const [isReportCardOpen, setIsReportCardOpen] = useState(false);
  const {
    allMonthlyData,
    yearlyData,
    cumulativeData,
    calendarData,
    levelData,
    longestStreak,
  } = processedData;

  const chartData = useMemo(
    () =>
      allMonthlyData
        .slice(0, 12)
        .reverse()
        .map((m) => ({
          name: `${m.year}/${m.month}`,
          文字数: m.word_count,
          作品数: m.book_count,
          話数: m.chapter_count,
        })),
    [allMonthlyData]
  );

  const { readingTrendsData, comparisonData, personalInsightsData } =
    useMemo(() => {
      // --- Comparison Data Calculation ---
      const now = new Date();
      const currentYear = now.getFullYear();
      const currentMonth = now.getMonth() + 1;

      const prevMonthDate = new Date(now);
      prevMonthDate.setMonth(prevMonthDate.getMonth() - 1);
      const prevMonthYear = prevMonthDate.getFullYear();
      const prevMonth = prevMonthDate.getMonth() + 1;

      const thisMonthData = allMonthlyData.find(
        (d) => d.year === currentYear && d.month === currentMonth
      );
      const prevMonthData = allMonthlyData.find(
        (d) => d.year === prevMonthYear && d.month === prevMonth
      );
      const thisYearData = yearlyData.find((d) => d.year === currentYear);
      const prevYearData = yearlyData.find((d) => d.year === currentYear - 1);

      const calcComparison = (
        current: number,
        previous: number
      ): { percentage: number; direction: "up" | "down" | "same" } => {
        if (previous === 0) {
          return {
            percentage: current > 0 ? 100 : 0,
            direction: current > 0 ? "up" : "same",
          };
        }
        const percentage = Math.abs(
          Math.round(((current - previous) / previous) * 100)
        );
        const direction: "up" | "down" | "same" =
          current > previous ? "up" : current < previous ? "down" : "same";
        return { percentage, direction };
      };

      const monthlyComp = calcComparison(
        thisMonthData?.word_count || 0,
        prevMonthData?.word_count || 0
      );
      const yearlyComp = calcComparison(
        thisYearData?.word_count || 0,
        prevYearData?.word_count || 0
      );

      const datesFor30Days: { date: Date; words: number }[] = [];
      calendarData.forEach((words, dateStr) =>
        datesFor30Days.push({ date: new Date(dateStr), words })
      );

      const today = new Date();
      const thirtyDaysAgo = new Date(new Date().setDate(today.getDate() - 30));
      const sixtyDaysAgo = new Date(new Date().setDate(today.getDate() - 60));

      const current30DaysWords = datesFor30Days
        .filter((d) => d.date > thirtyDaysAgo && d.date <= today)
        .reduce((sum, d) => sum + d.words, 0);
      const previous30DaysWords = datesFor30Days
        .filter((d) => d.date > sixtyDaysAgo && d.date <= thirtyDaysAgo)
        .reduce((sum, d) => sum + d.words, 0);
      const last30DaysComp = calcComparison(
        current30DaysWords,
        previous30DaysWords
      );

      const finalComparisonData: ComparisonData = {
        monthly: {
          current: thisMonthData?.word_count || 0,
          previous: prevMonthData?.word_count || 0,
          ...monthlyComp,
        },
        yearly: {
          current: thisYearData?.word_count || 0,
          previous: prevYearData?.word_count || 0,
          ...yearlyComp,
        },
        last30days: {
          current: current30DaysWords,
          previous: previous30DaysWords,
          ...last30DaysComp,
        },
      };

      // --- Personal Insights Calculation ---
      const dayCounts: { [day: number]: number } = {
        0: 0,
        1: 0,
        2: 0,
        3: 0,
        4: 0,
        5: 0,
        6: 0,
      };
      calendarData.forEach((words, dateStr) => {
        const dayOfWeek = new Date(dateStr).getDay();
        dayCounts[dayOfWeek] += words;
      });

      const maxDayIndex = Object.keys(dayCounts).reduce((a, b) =>
        dayCounts[Number(a)] > dayCounts[Number(b)] ? a : b
      );
      const dayNames = [
        "日曜日",
        "月曜日",
        "火曜日",
        "水曜日",
        "木曜日",
        "金曜日",
        "土曜日",
      ];

      let bestMonthInfo = { month: "N/A", words: 0 };
      if (allMonthlyData.length > 0) {
        const best = allMonthlyData.reduce((prev, current) =>
          prev.word_count > current.word_count ? prev : current
        );
        bestMonthInfo = {
          month: `${best.year}年${best.month}月`,
          words: best.word_count,
        };
      }

      let bestYearInfo = { year: 0, words: 0 };
      if (yearlyData.length > 0) {
        const best = yearlyData.reduce((prev, current) =>
          prev.word_count > current.word_count ? prev : current
        );
        bestYearInfo = { year: best.year, words: best.word_count };
      }

      const totalActiveDays = calendarData.size;
      const totalWords = cumulativeData.word_count;
      const dailyAvg =
        totalActiveDays > 0 ? Math.round(totalWords / totalActiveDays) : 0;

      const totalMonthsWithActivity = allMonthlyData.length;
      const avgBooksPerMonth =
        totalMonthsWithActivity > 0
          ? parseFloat(
              (cumulativeData.book_count / totalMonthsWithActivity).toFixed(1)
            )
          : 0;

      const totalBooks = cumulativeData.book_count;
      const avgWordsPerBook =
        totalBooks > 0 ? Math.round(totalWords / totalBooks) : 0;

      const finalPersonalInsightsData: PersonalInsightsData = {
        bestDayOfWeek: dayNames[Number(maxDayIndex)],
        bestMonth: bestMonthInfo,
        dailyAverage: dailyAvg,
        avgBooksPerMonth: avgBooksPerMonth,
        avgWordsPerBook: avgWordsPerBook,
        bestYear: bestYearInfo,
      };

      // --- Reading Trends ---
      const finalReadingTrendsData = dayNames.map((day, index) => ({
        day: day.charAt(0),
        文字数: dayCounts[index] || 0,
      }));

      return {
        readingTrendsData: finalReadingTrendsData,
        comparisonData: finalComparisonData,
        personalInsightsData: finalPersonalInsightsData,
      };
    }, [allMonthlyData, yearlyData, cumulativeData, calendarData]);

  return (
    <>
      <div className="space-y-4 md:space-y-6 animate-fade-in">
        <div className="flex flex-col md:flex-row justify-between md:items-center gap-2">
          <h1 className="text-3xl md:text-4xl font-bold text-on-surface">
            ダッシュボード
          </h1>
          <button
            onClick={() => setIsReportCardOpen(true)}
            className="flex items-center gap-2 bg-primary text-white font-semibold py-2 px-4 rounded-lg hover:bg-primary-variant transition-colors shadow-lg shadow-primary/30"
          >
            <ShareIcon className="w-5 h-5" />
            読書レポートをシェア
          </button>
        </div>

        {/* Stat Cards */}
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 md:gap-6">
          <StatCard
            title="累計読了作品数"
            value={cumulativeData.book_count.toLocaleString()}
            unit="作品"
            icon={<BookIcon className="w-8 h-8" />}
            accentColor="bg-primary"
            delay={100}
          />
          <StatCard
            title="累計読了話数"
            value={cumulativeData.chapter_count.toLocaleString()}
            unit="話"
            icon={<ChapterIcon className="w-8 h-8" />}
            accentColor="bg-secondary"
            delay={200}
          />
          <StatCard
            title="累計読了文字数"
            value={cumulativeData.word_count.toLocaleString()}
            unit="文字"
            icon={<WordIcon className="w-8 h-8" />}
            accentColor="bg-yellow-400"
            delay={300}
          />
        </div>

        {/* Level & Goal */}
        <div className="grid grid-cols-1 lg:grid-cols-2 gap-4 md:gap-6">
          <AnimatedCard delay={400} className="min-h-[220px]">
            <LevelProgress data={levelData} />
          </AnimatedCard>
          <AnimatedCard delay={500} className="min-h-[220px]">
            <ReadingGoal monthlyData={allMonthlyData} />
          </AnimatedCard>
        </div>

        {/* Monthly Trend Chart */}
        <AnimatedCard delay={600}>
          <h2 className="text-2xl font-bold text-on-surface mb-4">
            月間読書トレンド
          </h2>
          <div className="h-80">
            <ResponsiveContainer width="100%" height="100%">
              <BarChart
                data={chartData}
                margin={{ top: 5, right: 20, left: -10, bottom: 5 }}
              >
                <CartesianGrid strokeDasharray="3 3" stroke="#ffffff20" />
                <XAxis dataKey="name" stroke="#9ca3af" />
                <YAxis
                  stroke="#9ca3af"
                  tickFormatter={(v) => `${Number(v) / 1000}k`}
                />
                <Tooltip
                  contentStyle={{
                    backgroundColor: "rgba(30, 30, 36, 0.8)",
                    border: "1px solid #ffffff20",
                    color: "#fff",
                  }}
                  formatter={(v: number) => v.toLocaleString()}
                />
                <Legend />
                <Bar dataKey="文字数" fill="#bb86fc" />
              </BarChart>
            </ResponsiveContainer>
          </div>
        </AnimatedCard>

        {/* Activity Calendar */}
        <AnimatedCard delay={700}>
          <div className="flex justify-between items-center mb-4">
            <h2 className="text-2xl font-bold text-on-surface flex items-center gap-2">
              <CalendarIcon className="w-6 h-6" />
              活動カレンダー
            </h2>
            <p className="text-sm text-gray-400">
              {calendarData.size} 日間の活動
            </p>
          </div>
          <ActivityCalendar data={calendarData} />
        </AnimatedCard>

        {/* Comparison & Personal Insights */}
        <div className="grid grid-cols-1 lg:grid-cols-2 gap-4 md:gap-6">
          <AnimatedCard delay={800}>
            <ComparisonStats data={comparisonData} />
          </AnimatedCard>
          <AnimatedCard delay={900}>
            <PersonalInsights data={personalInsightsData} />
          </AnimatedCard>
        </div>

        <AnimatedCard delay={1000}>
          <Roadmap />
        </AnimatedCard>
      </div>
      <ReportCardModal
        isOpen={isReportCardOpen}
        onClose={() => setIsReportCardOpen(false)}
        processedData={processedData}
      />
    </>
  );
};

export default Dashboard;
